\section{Theory}

\subsection{Hickey-Cohen Generation of Hypergraphs}

  In this section, we will attempt to use the Hick Hickey-Cohen approach to generating uniform random strings to uniformly generate hypergraphs from a hypergraph grammar. 

  The function to calculate the number of terminal strings in a vector of  $f$ is expressed in terms of the functions $T(\beta)$ and $A(\beta)$ where $T(\beta)$ is the number of terminals in the string $\beta$ and $A(\beta)$ is a vector whose $i$th component is the number of occurences of $N_i$ in the string $\beta$. We must first redefine these functions for hypergraphs.

  Our grammar productions are named the same as before:
  \[P = \left\{\pi_{ij} : N_i \to \alpha_{ij} | i = 1,\dots,r, j = 1, \dots,s_i \right\}\]
  But instead of strings, now $N_1,\dots,N_r$ are non-terminal hyperedges and $\alpha_{ij}$ is the graph derivation.

  $A(\beta)$ is now a vector whose $i$th component is the number of occurences of the non-terminal edge $N_i$ in the grah $\beta$.

  In order to define $A(\beta)$ we must decide what `size' means for a hypergraph. This size must never decrease after applying a derivation and the following property must hold for derivations $d_1$ and $d_2$.
  \[
  T(\beta) + T(\alpha_{ij}) = T(\beta \Rightarrow \pi_{ij})
  \]
  What this means is when replacing a hyperedge with a subgraph ($\beta_1$), the overall size ($T(\beta)$) will increase by the size of the subgraph ($T(\beta_1)$).

  I have chosen the following where $t_\beta$ is the number of terminal hyperedges in graph $\beta$, $v_\beta$ is the number of vertices in the graph and $x_\beta$ is the number of external vertices in the graph.

  \[T(\beta) = t_\beta + v_\beta - x_\beta\]

  It is also possible to define $T(\beta)$ without non-terminal edges, so $T(\beta) = v_\beta - x_\beta$. The distiction is whether the user wants to limit number of vertices and terminal edges or just vertices. It is required to not count external nodes in this case, because these nodes get merged and the aforementioned property will not hold.

  The method now generates a graph of size $n$. To generate a single graph the program does the following.

  \begin{itemize}
    \item Start with a graph $\beta$ which is initial graph 
    \item For each non-terminal hyperedge in $\beta$ where the label of the hyperedge is $N_i$, the following sub-procedure must be done. This is repeated until there is no non-terminals left.

    It is worth noting that it doesn't matter which order the hyperedge is picked since it is known that hyperedge replacement can be performed in any order with the same output.
    \begin{itemize}
    \item Choose a production from the set $\left(\pi_{i1},\dots,\pi_{is_i}\right)$ by choosing a random number and using discrete cumulative probability distribution where production $\pi_{ij}$ has the probability $p_{ij}(\beta, n)$ of being chosen.

    For example, if the probabilities for $(\pi_{i1}, \pi_{i2}, \pi_{i2})$ are $(\frac{1}{2}, \frac{1}{4}, \frac{1}{4})$. A random number $0 \leq r \leq 1$ is used to choose the production $p$ accordingly. Therefore
    \[
    p = \left\{\begin{aligned}
      \pi_{i1}, \quad & r \le 0.5 \\
      \pi_{i2}, \quad & 0.5 < r \le 0.75 \\
      \pi_{i3}, \quad & 0.75 < r \le 1 \\
    \end{aligned}\right.
    \]
    The probability $\pi_{ij}$ may be zero in the case where applying this production can never produce a graph of size $n$. In this case the production should not be considered in the above choice.

    \item The production $p$ is applied the the graph $\beta$ which may add extra terminals and non-terminals.
    \end{itemize}

    \item $\beta$ is now a random graph of size $n$. 
  \end{itemize}

  If the user wants multiple graphs he can run this procedure as many times as needed.

\subsubsection{Example}

\input{figures/theory-nonterminal}

\input{figures/theory-binarytree}

The program first computes values for $g_A(t)$ for $1 \leq t \leq n$ using the following equation.

\begin{align*}
  g_{N_i}(t) &= \sum_{j=1}^{s_i} \left(g_{N_1}^{(\alpha_{ij})} * \hdots * g_{N_r}^{(\alpha_{rj})}\right)(t - T(\alpha_{ij})) \\
  g_A(t) &= g_A(t-2) + (g_A^{(2)})(t-4) + \delta_0(t)
\end{align*}

Results for $n=11$.

\begin{figure}[!h]
\centering
\begin{tabular}{l|l}
$g_A(0)$ & 1 \\
$g_A(1)$ & 0 \\
$g_A(2)$ & 1 \\
$g_A(3)$ & 0 \\
$g_A(4)$ & 2 \\
$g_A(5)$ & 0 \\
$g_A(6)$ & 4 \\
$g_A(7)$ & 0 \\
$g_A(8)$ & 9 \\
$g_A(9)$ & 0 \\
$g_A(10)$ & 21 \\
$g_A(11)$ & 0 \\
\end{tabular}
\end{figure}

And now the program can generate as many graphs as needed, here we have generated six.

\input{figures/theory-generation}

\subsection{Ambiguous Grammars}

In general an ambiguous grammar is a grammar where there is a string that can have more than one \todo{Define leftmost derivation} leftmost derivation. This also applies to hypergraph grammars.

The Hickey-Cohen generation algorithm requires the input grammar to be unambiguous in order to \emph{uniformly} generate terminal graphs. However, if the input grammar is ambiguous then the algorithm will generate graphs where each \emph{lefthand derivation} is uniformly distributed. Therefore if a terminal graph in the grammar has two lefthand derivations then this terminal graph has double the probability of being generated and therefore the generation is no longer uniform.

\todo{Example}

Unfortunately it is undecidable to know whether a grammar is ambiguous and impossible to convert an ambiguous grammar to an unambigous grammar. However as long as the user is aware that using an ambiguous grammar will not produce uniform results then there should be no problem.

\subsection{Cyclic Grammars}

A cyclic grammar is a grammar where a non-terminal can derive exactly itself. This can be directly ($A \Rightarrow A$) or indirectly ($A \Rightarrow B \Rightarrow A$). If a grammar contains epsilon productions, it may be cycling also in the case where $A \to AB$ and $B \to \epsilon$

The Hickey-Cohen approach is invalid on a cyclic grammar because the number of deriving strings from a cyclic non-terminal is infinite. We can observe this by expanding the generating function for a a simple grammar $A \to B | a$ and $B \to A$. The generating function becomes $g_A(t) = g_B(t) + \delta_0(t-1) = g_A(t) + \delta_0(t-1)$ which is recursive and cannot be computed.

In order to test if a grammar is cyclic, firstly the grammar must be transformed to an $\epsilon$-free grammar. This means there is no derivations to $\epsilon$ or there is exactly one $\epsilon$-production $S \to \epsilon$ and $S$ does not appear on the rightside of any production. In string grammars $\epsilon$ means the empty string, in hypergraph grammars $\epsilon$ means a graph containing just external nodes.

I will modify the algorithm to work with hypergraph grammars.

\begin{itemize}
\item Given a hypergraph grammar $G = \langle N, T, P, S \rangle$
\item Construct $N_\epsilon = \left\{A | A \in N \textrm{ and } A \Rightarrow^{+} \epsilon \right\}$. This is the set of non-terminals which possibly derive to $\epsilon$.

Define a predicate `$a$ produces $\epsilon$' which yields true if a non-terminal $a$ produces $\epsilon$. It is defined by the following: $A \to \langle R, ext \rangle$ is in $P$ where $R = \langle V, E, att, lbl\rangle$, $V = ext$ and $E = \{\}$. This means the production replaces a hyperedge with the empty graph.
\begin{enumerate}
\item Let $V_0 = \{A| \textrm{if $A \in N$ produces $\epsilon$}\}$ and set $i = 1$
\item Let $V_i = \left\{A| \textrm{if } A \to X_1X_2\dots X_n \textrm{ where } X_k \in V_{i-1}\right\} \cup V_{i-1}$
\item If $V_i \neq V_{i-1}$ set $i=i+1$ and repeat step 2. Otherwise let $N_\epsilon = V_i$
\end{enumerate}
Since $V_i \subseteq N$ then this procedure will terminate after a finite number of steps.
\item Let $P'$ be the set of productions constructed by the following
\begin{enumerate}
\item If $A \to \langle R, ext \rangle$ is in $P$, $k \geq 0$ and each $B_i$ is in $N_\epsilon$ but no symbols in any $a_j$ are in $N_\epsilon$, then add to $P'$ all productions in the form of
\[
A \to a_0 X_1 a_1 X_2 a_2 \dots X_k a_k
\]
Where $X_i$ is either $B_i$ or $\epsilon$, without adding $A \to \epsilon$.
\item If $S$ is in $N_\epsilon$, add to $P'$ the productions
\[S' \to \epsilon|S\]
Where $S'$ is a new symbol, and let $N' = N \cup \{S'\}$. Otherwise let $N' = N$ and $S' = S$
\end{enumerate}
\item Let $G' = \langle N', \Sigma, P', S' \rangle$
\end{itemize}

\paragraph{}

For example, given the grammar with the following productions in $P$:
\begin{align*}
A &\to AaBbCc | \epsilon \\
B &\to AB | \epsilon \\
C &\to c | d
\end{align*}
Then $V_\epsilon = \{A, B\}$ and the productions added to $P'$ would be:
\begin{align*}
A &\to AaBbCc | aBbCc | AabCc | abCc \\
B &\to AB | A | B \\
C &\to c | d \\
\end{align*}
This is an equivalent grammar without any $\epsilon$ productions.

\todo{Algorithm 2.10 The Theory of Parsin, Translation and Compiling Volume 1}

% The Hickey-Cohen approach also has a problem with the grammar $A \Rightarrow AB$, the counting function is: 
% \begin{align}
% g_A(t) &= (g_A * g_B)(t)
% &= \sum_{k=0}^{t} g_A(k) * g_B(t-k)
% \end{align}

% As we can see, this is a recursive function when $k=t$. This will cause an infinite loop when implemented in code so it would be good to remove this case. If it is known that $g_N(0)=0$ then we can update the function 
